{
    TMS9918 Emulation
    Written by Marco Maccaferri <macca@maccasoft.com>
}

CON

    video_pin   = 32+7*3 addpins 1


OBJ

    video : "tms9918_cvbs"

PUB start(tms_regs, tms_vram, tms_bitmap) | cog

    _regs := tms_regs
    _vram := tms_vram
    _bitmap := tms_bitmap
    cog := coginit(16, @driver, 0)

    video.start(0, 378, _bitmap, video_pin, _regs, 1 << cog)   ' NTSC
    'video.start(1, 416, _bitmap, video_pin, _regs, 1 << cog)   ' PAL

DAT

                org     $000

driver
.frame
                'getct   t1

                mov     ptra, _regs
                mov     ptrb, _bitmap

                rdbyte  regs+0, ptra[0]
                rdbyte  regs+1, ptra[1]

                test    regs+0, #TMSMODE3    wz ' graphics mode II

                rdbyte  regs+2, ptra[2]
                shl     regs+2, #10             ' name table base address * $400
                rdbyte  regs+3, ptra[3]
                shl     regs+3, #6              ' color table base address * $40
    if_nz       andn    regs+3, vdp_8k_mask     ' limit color table to 8k boundaries
                rdbyte  regs+4, ptra[4]
                shl     regs+4, #11             ' pattern generator base address * $800
    if_nz       andn    regs+4, vdp_8k_mask     ' limit pattern table to 8k boundaries
                rdbyte  regs+5, ptra[5]
                shl     regs+5, #7              ' sprite attribute table base address * $80
                rdbyte  regs+6, ptra[6]
                shl     regs+6, #11             ' sprite pattern generator base address * $800

                rdbyte  regs+7, ptra[7]

                add     regs+2, _vram
                add     regs+3, _vram
                add     regs+4, _vram
                add     regs+5, _vram
                add     regs+6, _vram

                mov     loff, #0
                mov     scnt, #0
.line           call    #render
                add     ptrb, #256
                incmod  loff, #7
                incmod  scnt, #192-1    wc
    if_nc       jmp     #.line

                'getct   t2
                'sub     t2, t1
                'debug(UDEC(t2))
                'jmp     #$

                'cogatn  #%00000001
                waitatn
                jmp     #.frame

t1              long    0
t2              long    0

render
                mov     ptra, ptrb

                test    regs+1, #TMSMODE2    wz ' multicolor mode
    if_nz       jmp     #multicolor_mode

                test    regs+1, #TMSMODE1    wz ' text mode
    if_z        jmp     #graphics_mode

text_mode
                mov     ctmp, regs+7            ' background color
                and     ctmp, #$0F
                mov     a, regs+7               ' foreground color
                shr     a, #4
                setbyte ctmp, a, #1

                mov     cbuf+0, ctmp
                movbyts cbuf+0, #0
                wrlong  cbuf+0, ptra++
                wrlong  cbuf+0, ptra++

                rdfast  #0, regs+2              ' fast-read nametable with fifo

                rep     @.endloop, #40
.loop           rfbyte  ptrc                    ' read tile number to display
                shl     ptrc, #3                ' 8 bytes per tile
                add     ptrc, regs+4
                add     ptrc, loff
                rdbyte  a, ptrc                 ' pixels, 1 bit per pixel, from msb

                rev     a
                shr     a, #24
                mergew  a
                mov     cbuf+0, ctmp
                movbyts cbuf+0, a
                wrlong  cbuf+0, ptra++
                shr     a, #8
                mov     cbuf+1, ctmp
                movbyts cbuf+1, a
                wrword  cbuf+1, ptra++
.endloop

                mov     cbuf+0, ctmp
                movbyts cbuf+0, #0
                wrlong  cbuf+0, ptra++
                wrlong  cbuf+0, ptra++

                cmp     loff, #7        wz
    if_z        add     regs+2, #40

                ret

multicolor_mode
                mov     a, scnt
                shr     a, #2
                and     a, #$07

                rdfast  #0, regs+2              ' fast-read nametable with fifo

                rep     @.endloop, #32
.loop           rfbyte  ptrc                    ' read tile number to display
                shl     ptrc, #3
                add     ptrc, regs+4            ' points to color table
                add     ptrc, a

                rdbyte  cbuf+0, ptrc            ' colors

                mov     cbuf+1, cbuf+0
                and     cbuf+1, #$0F wz
    if_z        setnib  cbuf+1, regs+7, #0
                shr     cbuf+0, #4   wz
    if_z        setnib  cbuf+0, regs+7, #0

                movbyts cbuf+0, #%%0000
                wrlong  cbuf+0, ptra++
                movbyts cbuf+1, #%%0000
                wrlong  cbuf+1, ptra++
.endloop

                cmp     loff, #7        wz
    if_z        add     regs+2, #32

                jmp     #sprites

graphics_mode
                mov     b, loff

                test    regs+0, #TMSMODE3    wz ' graphics mode II
    if_nz       mov     a, scnt
    if_nz       shr     a, #6                   ' divide by 64 (8 rows by 8 pixels)
    if_nz       shl     a, #11                  ' multiply by 2048
    if_nz       add     b, a

                test    regs+0, #TMSMODE3 wz    ' graphics mode II
                bitnz   .shlr, #21              ' patch shl(0)/shr(1)

                rdfast  #0, regs+2              ' fast-read nametable with fifo

                rep     @.endloop, #32
.loop           rfbyte  ptrc                    ' read tile number to display

                mov     ptrd, ptrc
.shlr           shl     ptrd, #3
                add     ptrd, regs+3            ' points to color table
                add     ptrd, b
                rdbyte  a, ptrd                 ' colors

                getnib  cbuf+0, a, #0
                and     cbuf+0, #$0F wz
    if_z        setnib  cbuf+0, regs+7, #0
                getnib  cbuf+1, a, #1
                and     cbuf+1, #$0F wz
    if_z        setnib  cbuf+1, regs+7, #0

                setbyte cbuf+0, cbuf+1, #1
                mov     cbuf+1, cbuf+0

                shl     ptrc, #3                ' 8 bytes per tile
                add     ptrc, regs+4
                add     ptrc, b
                rdbyte  a, ptrc                 ' pixels, 1 bit per pixel, from msb

                rev     a
                shr     a, #24
                mergew  a
                movbyts cbuf+0, a
                wrlong  cbuf+0, ptra++
                shr     a, #8
                movbyts cbuf+1, a
                wrlong  cbuf+1, ptra++
.endloop

                cmp     loff, #7        wz
    if_z        add     regs+2, #32

                ' fall through

sprites
                mov     lcnt, #4                ' sprite scanline limit
                mov     ccnt, #TMSSPRITES       ' number of sprites

                mov     b, #8
                test    regs+1, #TMSSPRSIZE wz
    if_nz       shl     b, #1
                test    regs+1, #TMSSPRMAG  wz
    if_nz       shl     b, #1

                rdfast  #0, regs+5
.loop           rflong  sprt

                test    sprt, TMSSPRCOLOR wz    ' check sprite color
    if_z        jmp     #.next                  ' skip if transparent

                mov     y, sprt
                shl     y, #24
                sar     y, #24                  ' sign-extend y
                cmps    y, neg_clip wc
    if_c        and     y, #$FF                 ' max -32
                cmp     y, #$D0 wz              ' end of sprites processing
    if_z        ret

                mov     a, scnt                 ' check sprite scanline visibility
                subs    a, y    wc
    if_c        jmp     #.next
                cmp     a, b    wc
    if_nc       jmp     #.next

                mov     ptrc, sprt
                shr     ptrc, #16
                and     ptrc, #$FF
                shl     ptrc, #3
                add     ptrc, regs+6
                test    regs+1, #TMSSPRMAG  wz
    if_nz       shr     a, #1
                add     ptrc, a

                mov     ctmp, sprt              ' set pixel color
                shr     ctmp, #24
                and     ctmp, #$0F          wz
    if_z        setnib  ctmp, regs+7, #0

                mov     x, sprt
                shr     x, #8
                and     x, #$FF
                test    sprt, TMSEARLYCLK   wz
    if_nz       sub     x, #32
                mov     ptra, ptrb
                add     ptra, x

                test    regs+1, #TMSSPRSIZE wz
    if_z        mov     ecnt, #8
    if_nz       mov     ecnt, #16

                rdbyte  sprt, ptrc
    if_nz       shl     sprt, #8
    if_nz       add     ptrc, #16
    if_nz       rdbyte  a, ptrc
    if_nz       or      sprt, a

                mov     a, #$80
    if_nz       shl     a, #8

                test    regs+1, #TMSSPRMAG  wz  ' Z=!magnify

                rep     @.end_draw, ecnt
.draw           cmps    x, #0       wc          ' check pixel outside left border
    if_c        jmp     #.l1                    ' skip if outside
                cmps    x, #256     wc          ' check pixel outside right border
    if_nc       jmp     #.end_draw              ' nothing more to do if outside
                test    sprt, a     wc          ' check pixel visibility
    if_c        wrbyte  ctmp, ptra              ' overwrite if visible
                add     ptra, #1                ' move to next location
    if_c_and_nz wrbyte  ctmp, ptra              ' repeat if magnify (Z=0)
    if_nz       add     ptra, #1                ' |
.l1             shr     a, #1
                add     x, #1
.end_draw

                sub     lcnt, #1    wz          ' limit sprites on scanline
    if_z        ret

.next           djnz    ccnt, #.loop
                ret

_regs           long    0
_vram           long    0
_bitmap         long    0

vdp_8k_mask     long    $1FFF
neg_clip        long    -32

TMSEARLYCLK     long    %10000000_00000000_00000000_00000000
TMSSPRCOLOR     long    %00001111_00000000_00000000_00000000

a               res     1
b               res     1
x               res     1
y               res     1

scnt            res     1
ccnt            res     1
lcnt            res     1
ecnt            res     1
loff            res     1

ctmp            res     1
cbuf            res     4

'c0              res     1
'c1              res     1
sprt            res     1

ptrc            res     1
ptrd            res     1

regs            res     8

                fit     $1F0

CON

    TMSMODE3   = %00000010      ' mode bit 3
    TMSEXTVID  = %00000001      ' external video

    ' register 1 control bits
    TMS4K16K   = %10000000      ' 4/16K RAM
    TMSBLANK   = %01000000      ' screen blank
    TMSINTEN   = %00100000      ' interrupt enable
    TMSMODE1   = %00010000      ' mode bit 1
    TMSMODE2   = %00001000      ' mode bit 2
    TMSSPRSIZE = %00000010      ' sprite size
    TMSSPRMAG  = %00000001      ' sprite magnification

    TMSVSYNC   = %10000000      ' framce sync

    TMSSPRITES = 32